{"version":3,"file":"index.js","sources":["../../../node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","../src/positioning.ts","../src/options.ts","../src/icons/close.svg?raw","../src/popupPicker.ts","../src/index.ts"],"sourcesContent":["function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset(middlewareArguments) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      await apply({ ...middlewareArguments,\n        ...dimensions\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n\n      if (rects.floating.width !== nextDimensions.width || rects.floating.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)\n  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return composedOffsetParent(element);\n}\n/**\n * Polyfills the old offsetParent behavior from before the spec was changed:\n * https://github.com/w3c/csswg-drafts/issues/159\n */\n\n\nfunction composedOffsetParent(element) {\n  let {\n    offsetParent\n  } = element;\n  let ancestor = element;\n  let foundInsideSlot = false;\n\n  while (ancestor && ancestor !== offsetParent) {\n    const {\n      assignedSlot\n    } = ancestor;\n\n    if (assignedSlot) {\n      let newOffsetParent = assignedSlot.offsetParent;\n\n      if (getComputedStyle(assignedSlot).display === 'contents') {\n        const hadStyleAttribute = assignedSlot.hasAttribute('style');\n        const oldDisplay = assignedSlot.style.display;\n        assignedSlot.style.display = getComputedStyle(ancestor).display;\n        newOffsetParent = assignedSlot.offsetParent;\n        assignedSlot.style.display = oldDisplay;\n\n        if (!hadStyleAttribute) {\n          assignedSlot.removeAttribute('style');\n        }\n      }\n\n      ancestor = assignedSlot;\n\n      if (offsetParent !== newOffsetParent) {\n        offsetParent = newOffsetParent;\n        foundInsideSlot = true;\n      }\n    } else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {\n      break;\n    }\n\n    ancestor = isShadowRoot(ancestor) && ancestor.host || ancestor.parentNode;\n  }\n\n  return offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    var _observer;\n\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { autoUpdate, computePosition, getOverflowAncestors };\n","import { autoUpdate, ComputePositionConfig, computePosition, Placement, flip, offset, autoPlacement, shift } from '@floating-ui/dom';\nimport { PopupPickerController } from './popupPicker';\nimport { Position, RelativePosition, FixedPosition, PositionLostStrategy } from './types';\n\nexport type PositionCleanup = () => void;\n\nexport async function setPosition(picker: PopupPickerController, pickerElement: HTMLElement, referenceElement: HTMLElement | undefined, position: Position): Promise<PositionCleanup> {\n  if (!position) {\n    throw new Error('Must provide a positioning option');\n  }\n\n  return await (typeof position === 'string' ? \n    setRelativePosition(picker, pickerElement, referenceElement, position) : \n    setFixedPosition(pickerElement, position));\n}\n\nasync function setRelativePosition(picker: PopupPickerController, pickerElement: HTMLElement, referenceElement: HTMLElement | undefined, placement: RelativePosition): Promise<PositionCleanup> {\n  if (!referenceElement) {\n    throw new Error('Reference element is required for relative positioning');\n  }\n\n  let config: Partial<ComputePositionConfig>;\n\n  if (placement === 'auto') {\n    config = {\n      middleware: [\n        autoPlacement(),\n        shift(),\n        offset({ mainAxis: 5, crossAxis: 12 })\n      ]\n    };\n  } else {\n    config = {\n      placement: placement as Placement,\n      middleware: [\n        flip(),\n        shift(),\n        offset(5)\n      ]\n    };\n  }\n\n  return autoUpdate(referenceElement, pickerElement, async () => {\n    if (!referenceElement.isConnected || !referenceElement.offsetParent) {\n      if (handlePositionLost(picker)) {\n        return;\n      }\n    }\n\n    const { x, y } = await computePosition(referenceElement, pickerElement, config);\n    Object.assign(pickerElement.style, {\n      position: 'absolute',\n      left: `${x}px`,\n      top: `${y}px`\n    });\n  });\n}\n\nfunction setFixedPosition(picker: HTMLElement, position: FixedPosition): PositionCleanup {\n  picker.style.position = 'fixed';\n\n  Object.entries(position).forEach(([key, value]) => {\n    picker.style[key] = value;\n  });\n\n  /* eslint-disable @typescript-eslint/no-empty-function */\n  return () => {};\n}\n\nfunction handlePositionLost(picker: PopupPickerController) {\n  switch (picker.options.onPositionLost) {\n    case 'close':\n      picker.close();\n      return true;\n    case 'destroy':\n      picker.destroy();\n      return true;\n    case 'hold':\n      return true;\n  }\n}","import { PopupOptions } from './types';\n\nconst defaultOptions: Partial<PopupOptions> = {\n  hideOnClickOutside: true,\n  hideOnEmojiSelect: true,\n  hideOnEscape: true,\n  position: 'auto',\n  showCloseButton: true,\n  onPositionLost: 'none'\n};\n\nexport function getOptions(options: Partial<PopupOptions> = {}): PopupOptions {\n  return { \n    ...defaultOptions,\n    rootElement: document.body,\n    ...options \n  } as PopupOptions;\n}\n","export default \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 320 512\\\"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d=\\\"M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z\\\"/></svg>\"","import {\n  animate,\n  getOptions as getPickerOptions,\n  EmojiPicker,\n  EventCallback,\n  Events,\n  createPicker,\n  FocusTrap,\n  PickerOptions,\n  ExternalEvent,\n  getPrefixedClasses,\n} from 'picmo';\nimport { PopupEvent } from './PopupEvents';\nimport { setPosition, PositionCleanup } from './positioning';\nimport { PopupOptions, Position } from './types';\nimport { getOptions } from './options';\n\nimport closeIcon from './icons/close.svg?raw';\n\ntype OpenOptions = {\n  referenceElement?: HTMLElement;\n  triggerElement?: HTMLElement;\n}\n\nconst classes = getPrefixedClasses(\n  'popupContainer',\n  'closeButton'\n);\n\nexport class PopupPickerController {\n  picker: EmojiPicker;\n  isOpen = false;\n\n  referenceElement?: HTMLElement;\n  triggerElement?: HTMLElement;\n  options: PickerOptions & PopupOptions;\n\n  private popupEl: HTMLElement;\n  private focusTrap: FocusTrap;\n  private positionCleanup: PositionCleanup;\n\n  private closeButton: HTMLButtonElement;\n  private externalEvents = new Events<PopupEvent>();\n\n  constructor(pickerOptions: Partial<PickerOptions>, popupOptions: Partial<PopupOptions>) {\n    this.options = { ...getOptions(popupOptions), ...getPickerOptions(pickerOptions) };\n\n    this.popupEl = document.createElement('div');\n    this.popupEl.classList.add(classes.popupContainer);\n    this.popupEl.classList.add(this.options.theme);\n\n    if (popupOptions.className) {\n      this.popupEl.classList.add(popupOptions.className);\n    }\n\n    if (this.options.showCloseButton) {\n      this.closeButton = document.createElement('button');\n      this.closeButton.type = 'button';\n      this.closeButton.classList.add(classes.closeButton);\n      this.closeButton.innerHTML = closeIcon;\n      this.closeButton.addEventListener('click', () => {\n        this.close();\n      });\n      this.popupEl.appendChild(this.closeButton);\n    }\n\n    const pickerContainer = document.createElement('div');\n    this.popupEl.appendChild(pickerContainer);\n\n    this.picker = createPicker({ ...this.options, rootElement: pickerContainer });\n    this.focusTrap = new FocusTrap();\n\n    this.picker.addEventListener('data:ready', () => {\n      this.focusTrap.activate(this.picker.el);\n      this.picker.setInitialFocus();\n    });\n\n    if (this.options.hideOnEmojiSelect) {\n      this.picker.addEventListener('emoji:select', () => {\n        this.close();\n        this.triggerElement?.focus();\n      });\n    }\n\n    if (this.options.hideOnClickOutside) {\n      this.onDocumentClick = this.onDocumentClick.bind(this);\n      document.addEventListener('click', this.onDocumentClick);\n    }\n\n    if (this.options.hideOnEscape) {\n      this.handleKeydown = this.handleKeydown.bind(this);\n      this.popupEl.addEventListener('keydown', this.handleKeydown);\n    }\n\n    this.referenceElement = this.options.referenceElement;\n    this.triggerElement = this.options.triggerElement;\n  }\n\n  /**\n   * Listens for a picker event.\n   *\n   * @param event The event to listen for\n   * @param callback The callback to call when the event is triggered\n   */\n  addEventListener(event: PopupEvent, callback: EventCallback) {\n    this.externalEvents.on(event, callback);\n    this.picker.addEventListener(event as ExternalEvent, callback);\n  }\n\n  removeEventListener(event: PopupEvent, callback: EventCallback) {\n    this.externalEvents.off(event, callback);\n    this.picker.removeEventListener(event as ExternalEvent, callback);\n  }\n\n  private handleKeydown(event: KeyboardEvent) {\n    if (event.key === 'Escape') {\n      this.close();\n      this.triggerElement?.focus();\n    }\n  }\n\n  /**\n   * Destroys the picker when it is no longer needed.\n   * After calling this method, the picker will no longer be usable.\n   *\n   * If this is called while the picker is open, it will be closed first.\n   *\n   * @returns a Promise that resolves when the close/destroy is complete.\n   */\n  async destroy() {\n    if (this.isOpen) {\n      await this.close();\n    }\n\n    document.removeEventListener('click', this.onDocumentClick);\n\n    this.picker.destroy();\n    this.externalEvents.removeAll();\n  }\n\n  /**\n   * Toggles the visible state of the picker\n   * If the picker is currently open, it will be closed, and if it si currently closed, it will be opened.\n   *\n   * @returns a Promise that resolves when the visibility state change is complete\n   */\n  toggle(options?: OpenOptions): Promise<void> {\n    return this.isOpen ? this.close() : this.open(options);\n  }\n\n  /**\n   * Opens the picker.\n   *\n   * @returns a Promise that resolves when the picker is finished opening\n   */\n  async open({ triggerElement, referenceElement }: OpenOptions = {}): Promise<void> {\n    if (this.isOpen) {\n      return;\n    }\n\n    if (triggerElement) {\n      this.triggerElement = triggerElement;\n    }\n\n    if (referenceElement) {\n      this.referenceElement = referenceElement;\n    }\n\n    await this.initiateOpenStateChange(true);\n\n    // Picker must be in the DOM in order to find the\n    // Hide it with opacity until it's ready to show.\n    this.popupEl.style.opacity = '0';\n\n    // Calculate position and add to DOM\n    this.options.rootElement.appendChild(this.popupEl);\n    await this.setPosition();\n\n    // Reset to the initial category and state\n    this.picker.reset(false);\n\n    // Picker is positioned and scrolled. \n    // Now we can show it with the animation.\n    await this.animatePopup(true);\n    await this.animateCloseButton(true);\n    this.picker.setInitialFocus();\n    this.externalEvents.emit('picker:open');\n  }\n\n  /**\n   * Closes the picker.\n   *\n   * @returns a Promise that resolves when the picker is finished closing\n   */\n  async close(): Promise<void> {\n    if (!this.isOpen) {\n      return;\n    }\n\n    await this.initiateOpenStateChange(false);\n    await this.animateCloseButton(false);\n    await this.animatePopup(false);\n\n    this.popupEl.remove();\n    this.picker.reset();\n    this.positionCleanup?.();\n\n    this.focusTrap.deactivate();\n    this.externalEvents.emit('picker:close');\n  }\n\n  /**\n   * Finds any pending (running) animations on the picker element.\n   *\n   * @returns an array of Animation objects that are in the 'running' state.\n   */\n  private getRunningAnimations(): Animation[] {\n    return this.picker.el.getAnimations().filter(animation => animation.playState === 'running');\n  }\n\n  /**\n   * Sets up the picker positioning.\n   */\n  private async setPosition() {\n    this.positionCleanup?.();\n      this.positionCleanup = await setPosition(\n        this,\n        this.popupEl,\n        this.referenceElement,\n        this.options.position as Position\n      );\n  }\n\n  /**\n   * Waits for all pending animations on the picker element to finish.\n   *\n   * @returns a Promise that resolves when all animations have finished\n   */\n  private awaitPendingAnimations(): Promise<Animation[]> {\n    return Promise.all(this.getRunningAnimations().map(animation => animation.finished));\n  }\n\n  /**\n   * Handles a click on the document, so that the picker is closed\n   * if the mouse is clicked outside of it.\n   *\n   * The picker will only be closed if:\n   * - The picker is currently open\n   * - The click target is not the trigger element or any of its children\n   * - The click target is not the picker or any of its children\n   *\n   * @param event The MouseEvent that was dispatched.\n   */\n  private onDocumentClick(event: MouseEvent) {\n    const clickedNode = event.target as Node;\n\n    const isClickOnTrigger = this.triggerElement?.contains(clickedNode);\n\n    if (this.isOpen && !this.picker.isPickerClick(event) && !isClickOnTrigger) {\n      this.close();\n    }\n  }\n\n  private animatePopup(openState: boolean) {\n    return animate(\n      this.popupEl,\n      {\n        opacity: [0, 1],\n        transform: ['scale(0.9)', 'scale(1)']\n      },\n      {\n        duration: 150,\n        id: openState ? 'show-picker' : 'hide-picker',\n        easing: 'ease-in-out',\n        direction: openState ? 'normal' : 'reverse',\n        fill: 'both'\n      },\n      this.options\n    );\n  }\n\n  private animateCloseButton(openState: boolean) {\n    if (this.closeButton) {\n      return animate(this.closeButton, {\n        opacity: [0, 1]\n      },\n      {\n        duration: 25,\n        id: openState ? 'show-close' : 'hide-close',\n        easing: 'ease-in-out',\n        direction: openState ? 'normal' : 'reverse',\n        fill: 'both',\n      },\n      this.options);\n    }\n  }\n\n  /**\n   * Prepares for an animation either for opening or closing the picker.\n   * If other animations are still running (this will happen when toggled rapidly), this will wait for them to finish.\n   *\n   * It will mark the new open state immediately then wait for pending animations to finish.\n   *\n   * @param openState The desired open state\n   */\n  private async initiateOpenStateChange(openState: boolean) {\n    this.isOpen = openState;\n    await this.awaitPendingAnimations();\n  }\n}\n","import { PickerOptions, createStyleInjector } from 'picmo';\nimport { PopupOptions } from './types';\nimport { PopupPickerController } from './popupPicker';\n\nimport css from './styles/index.css?inline';\n\nexport * from './types';\nexport { PopupPickerController };\n\nconst styleInject = createStyleInjector();\n\nexport function createPopup(pickerOptions: Partial<PickerOptions>, popupOptions: Partial<PopupOptions>) {\n  styleInject(css);\n\n  const popup = new PopupPickerController({\n    autoFocus: 'auto',\n    ...pickerOptions\n  }, popupOptions);\n  return popup;\n}\n"],"names":["getSide","placement","getAlignment","getMainAxisFromPlacement","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","commonY","mainAxis","length","commonAlign","side","isVertical","coords","computePosition","config","strategy","middleware","platform","rects","x","y","statefulPlacement","middlewareData","resetCount","i","name","fn","nextX","nextY","data","reset","expandPaddingObject","padding","getSideObjectFromPadding","rectToClientRect","rect","detectOverflow","middlewareArguments","options","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","elementClientRect","min","max","within","min$1","value","max$1","hash$1","getOppositePlacement","matched","getAlignmentSides","alignment","mainAlignmentSide","hash","getOppositeAlignmentPlacement","sides","allPlacements","acc","getPlacementList","autoAlignment","allowedPlacements","autoPlacement","_middlewareData$autoP","_middlewareData$autoP2","_middlewareData$autoP3","_middlewareData$autoP4","_placementsSortedByLe","detectOverflowOptions","placements","overflow","currentIndex","currentPlacement","main","cross","currentOverflows","allOverflows","nextPlacement","placementsSortedByLeastOverflow","a","b","placementThatFitsOnAllSides","overflows","resetPlacement","getExpandedPlacements","oppositePlacement","flip","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","fallbackPlacements","overflowsData","_middlewareData$flip$","_middlewareData$flip2","nextIndex","_overflowsData$map$so","d","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","crossAxis","alignmentAxis","offset","diffCoords","getCrossAxis","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","isWindow","getWindow","node","ownerDocument","getComputedStyle","getNodeName","getUAString","uaData","item","isHTMLElement","isElement","isNode","isShadowRoot","OwnElement","isOverflowElement","overflowX","overflowY","isTableElement","isContainingBlock","isFirefox","css","isLayoutViewport","round","getBoundingClientRect","includeScale","isFixedStrategy","_win$visualViewport$o","_win$visualViewport","_win$visualViewport$o2","_win$visualViewport2","clientRect","scaleX","scaleY","win","addVisualOffsets","width","height","getDocumentElement","getNodeScroll","getWindowScrollBarX","isScaled","getRectRelativeToOffsetParent","offsetParent","isOffsetParentAnElement","documentElement","scroll","offsets","offsetRect","getParentNode","getTrueOffsetParent","composedOffsetParent","ancestor","foundInsideSlot","assignedSlot","newOffsetParent","hadStyleAttribute","oldDisplay","getContainingBlock","currentNode","parent","getOffsetParent","window","getDimensions","convertOffsetParentRelativeRectToViewportRelativeRect","getViewportRect","html","visualViewport","layoutViewport","getDocumentRect","_element$ownerDocumen","body","getNearestOverflowAncestor","parentNode","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","target","updatedList","contains","child","rootNode","next","getInnerBoundingClientRect","top","left","getClientRectFromClippingAncestor","clippingParent","getClippingAncestors","clippingAncestors","clipperElement","getClippingRect","firstClippingAncestor","clippingRect","accRect","clippingAncestor","autoUpdate","update","_ancestorScroll","_ancestorResize","elementResize","animationFrame","ancestorScroll","ancestorResize","ancestors","observer","initialUpdate","frameId","prevRefRect","frameLoop","nextRefRect","_observer","computePosition$1","setPosition","picker","pickerElement","referenceElement","position","setRelativePosition","setFixedPosition","handlePositionLost","key","defaultOptions","getOptions","closeIcon","classes","getPrefixedClasses","PopupPickerController","pickerOptions","popupOptions","Events","getPickerOptions","pickerContainer","createPicker","FocusTrap","_a","event","callback","triggerElement","animation","clickedNode","isClickOnTrigger","openState","animate","styleInject","createStyleInjector","createPopup"],"mappings":"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"}