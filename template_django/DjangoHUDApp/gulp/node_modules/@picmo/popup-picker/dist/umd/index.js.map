{"version":3,"file":"index.js","sources":["../../../../node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","../../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","../../src/positioning.ts","../../src/options.ts","../../src/icons/close.svg?raw","../../src/popupPicker.ts","../../src/index.ts"],"sourcesContent":["function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset(middlewareArguments) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      await apply({ ...middlewareArguments,\n        ...dimensions\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n\n      if (rects.floating.width !== nextDimensions.width || rects.floating.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)\n  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return composedOffsetParent(element);\n}\n/**\n * Polyfills the old offsetParent behavior from before the spec was changed:\n * https://github.com/w3c/csswg-drafts/issues/159\n */\n\n\nfunction composedOffsetParent(element) {\n  let {\n    offsetParent\n  } = element;\n  let ancestor = element;\n  let foundInsideSlot = false;\n\n  while (ancestor && ancestor !== offsetParent) {\n    const {\n      assignedSlot\n    } = ancestor;\n\n    if (assignedSlot) {\n      let newOffsetParent = assignedSlot.offsetParent;\n\n      if (getComputedStyle(assignedSlot).display === 'contents') {\n        const hadStyleAttribute = assignedSlot.hasAttribute('style');\n        const oldDisplay = assignedSlot.style.display;\n        assignedSlot.style.display = getComputedStyle(ancestor).display;\n        newOffsetParent = assignedSlot.offsetParent;\n        assignedSlot.style.display = oldDisplay;\n\n        if (!hadStyleAttribute) {\n          assignedSlot.removeAttribute('style');\n        }\n      }\n\n      ancestor = assignedSlot;\n\n      if (offsetParent !== newOffsetParent) {\n        offsetParent = newOffsetParent;\n        foundInsideSlot = true;\n      }\n    } else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {\n      break;\n    }\n\n    ancestor = isShadowRoot(ancestor) && ancestor.host || ancestor.parentNode;\n  }\n\n  return offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    var _observer;\n\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { autoUpdate, computePosition, getOverflowAncestors };\n","import { autoUpdate, ComputePositionConfig, computePosition, Placement, flip, offset, autoPlacement, shift } from '@floating-ui/dom';\nimport { PopupPickerController } from './popupPicker';\nimport { Position, RelativePosition, FixedPosition, PositionLostStrategy } from './types';\n\nexport type PositionCleanup = () => void;\n\nexport async function setPosition(picker: PopupPickerController, pickerElement: HTMLElement, referenceElement: HTMLElement | undefined, position: Position): Promise<PositionCleanup> {\n  if (!position) {\n    throw new Error('Must provide a positioning option');\n  }\n\n  return await (typeof position === 'string' ? \n    setRelativePosition(picker, pickerElement, referenceElement, position) : \n    setFixedPosition(pickerElement, position));\n}\n\nasync function setRelativePosition(picker: PopupPickerController, pickerElement: HTMLElement, referenceElement: HTMLElement | undefined, placement: RelativePosition): Promise<PositionCleanup> {\n  if (!referenceElement) {\n    throw new Error('Reference element is required for relative positioning');\n  }\n\n  let config: Partial<ComputePositionConfig>;\n\n  if (placement === 'auto') {\n    config = {\n      middleware: [\n        autoPlacement(),\n        shift(),\n        offset({ mainAxis: 5, crossAxis: 12 })\n      ]\n    };\n  } else {\n    config = {\n      placement: placement as Placement,\n      middleware: [\n        flip(),\n        shift(),\n        offset(5)\n      ]\n    };\n  }\n\n  return autoUpdate(referenceElement, pickerElement, async () => {\n    if (!referenceElement.isConnected || !referenceElement.offsetParent) {\n      if (handlePositionLost(picker)) {\n        return;\n      }\n    }\n\n    const { x, y } = await computePosition(referenceElement, pickerElement, config);\n    Object.assign(pickerElement.style, {\n      position: 'absolute',\n      left: `${x}px`,\n      top: `${y}px`\n    });\n  });\n}\n\nfunction setFixedPosition(picker: HTMLElement, position: FixedPosition): PositionCleanup {\n  picker.style.position = 'fixed';\n\n  Object.entries(position).forEach(([key, value]) => {\n    picker.style[key] = value;\n  });\n\n  /* eslint-disable @typescript-eslint/no-empty-function */\n  return () => {};\n}\n\nfunction handlePositionLost(picker: PopupPickerController) {\n  switch (picker.options.onPositionLost) {\n    case 'close':\n      picker.close();\n      return true;\n    case 'destroy':\n      picker.destroy();\n      return true;\n    case 'hold':\n      return true;\n  }\n}","import { PopupOptions } from './types';\n\nconst defaultOptions: Partial<PopupOptions> = {\n  hideOnClickOutside: true,\n  hideOnEmojiSelect: true,\n  hideOnEscape: true,\n  position: 'auto',\n  showCloseButton: true,\n  onPositionLost: 'none'\n};\n\nexport function getOptions(options: Partial<PopupOptions> = {}): PopupOptions {\n  return { \n    ...defaultOptions,\n    rootElement: document.body,\n    ...options \n  } as PopupOptions;\n}\n","export default \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 320 512\\\"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d=\\\"M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z\\\"/></svg>\"","import {\n  animate,\n  getOptions as getPickerOptions,\n  EmojiPicker,\n  EventCallback,\n  Events,\n  createPicker,\n  FocusTrap,\n  PickerOptions,\n  ExternalEvent,\n  getPrefixedClasses,\n} from 'picmo';\nimport { PopupEvent } from './PopupEvents';\nimport { setPosition, PositionCleanup } from './positioning';\nimport { PopupOptions, Position } from './types';\nimport { getOptions } from './options';\n\nimport closeIcon from './icons/close.svg?raw';\n\ntype OpenOptions = {\n  referenceElement?: HTMLElement;\n  triggerElement?: HTMLElement;\n}\n\nconst classes = getPrefixedClasses(\n  'popupContainer',\n  'closeButton'\n);\n\nexport class PopupPickerController {\n  picker: EmojiPicker;\n  isOpen = false;\n\n  referenceElement?: HTMLElement;\n  triggerElement?: HTMLElement;\n  options: PickerOptions & PopupOptions;\n\n  private popupEl: HTMLElement;\n  private focusTrap: FocusTrap;\n  private positionCleanup: PositionCleanup;\n\n  private closeButton: HTMLButtonElement;\n  private externalEvents = new Events<PopupEvent>();\n\n  constructor(pickerOptions: Partial<PickerOptions>, popupOptions: Partial<PopupOptions>) {\n    this.options = { ...getOptions(popupOptions), ...getPickerOptions(pickerOptions) };\n\n    this.popupEl = document.createElement('div');\n    this.popupEl.classList.add(classes.popupContainer);\n    this.popupEl.classList.add(this.options.theme);\n\n    if (popupOptions.className) {\n      this.popupEl.classList.add(popupOptions.className);\n    }\n\n    if (this.options.showCloseButton) {\n      this.closeButton = document.createElement('button');\n      this.closeButton.type = 'button';\n      this.closeButton.classList.add(classes.closeButton);\n      this.closeButton.innerHTML = closeIcon;\n      this.closeButton.addEventListener('click', () => {\n        this.close();\n      });\n      this.popupEl.appendChild(this.closeButton);\n    }\n\n    const pickerContainer = document.createElement('div');\n    this.popupEl.appendChild(pickerContainer);\n\n    this.picker = createPicker({ ...this.options, rootElement: pickerContainer });\n    this.focusTrap = new FocusTrap();\n\n    this.picker.addEventListener('data:ready', () => {\n      this.focusTrap.activate(this.picker.el);\n      this.picker.setInitialFocus();\n    });\n\n    if (this.options.hideOnEmojiSelect) {\n      this.picker.addEventListener('emoji:select', () => {\n        this.close();\n        this.triggerElement?.focus();\n      });\n    }\n\n    if (this.options.hideOnClickOutside) {\n      this.onDocumentClick = this.onDocumentClick.bind(this);\n      document.addEventListener('click', this.onDocumentClick);\n    }\n\n    if (this.options.hideOnEscape) {\n      this.handleKeydown = this.handleKeydown.bind(this);\n      this.popupEl.addEventListener('keydown', this.handleKeydown);\n    }\n\n    this.referenceElement = this.options.referenceElement;\n    this.triggerElement = this.options.triggerElement;\n  }\n\n  /**\n   * Listens for a picker event.\n   *\n   * @param event The event to listen for\n   * @param callback The callback to call when the event is triggered\n   */\n  addEventListener(event: PopupEvent, callback: EventCallback) {\n    this.externalEvents.on(event, callback);\n    this.picker.addEventListener(event as ExternalEvent, callback);\n  }\n\n  removeEventListener(event: PopupEvent, callback: EventCallback) {\n    this.externalEvents.off(event, callback);\n    this.picker.removeEventListener(event as ExternalEvent, callback);\n  }\n\n  private handleKeydown(event: KeyboardEvent) {\n    if (event.key === 'Escape') {\n      this.close();\n      this.triggerElement?.focus();\n    }\n  }\n\n  /**\n   * Destroys the picker when it is no longer needed.\n   * After calling this method, the picker will no longer be usable.\n   *\n   * If this is called while the picker is open, it will be closed first.\n   *\n   * @returns a Promise that resolves when the close/destroy is complete.\n   */\n  async destroy() {\n    if (this.isOpen) {\n      await this.close();\n    }\n\n    document.removeEventListener('click', this.onDocumentClick);\n\n    this.picker.destroy();\n    this.externalEvents.removeAll();\n  }\n\n  /**\n   * Toggles the visible state of the picker\n   * If the picker is currently open, it will be closed, and if it si currently closed, it will be opened.\n   *\n   * @returns a Promise that resolves when the visibility state change is complete\n   */\n  toggle(options?: OpenOptions): Promise<void> {\n    return this.isOpen ? this.close() : this.open(options);\n  }\n\n  /**\n   * Opens the picker.\n   *\n   * @returns a Promise that resolves when the picker is finished opening\n   */\n  async open({ triggerElement, referenceElement }: OpenOptions = {}): Promise<void> {\n    if (this.isOpen) {\n      return;\n    }\n\n    if (triggerElement) {\n      this.triggerElement = triggerElement;\n    }\n\n    if (referenceElement) {\n      this.referenceElement = referenceElement;\n    }\n\n    await this.initiateOpenStateChange(true);\n\n    // Picker must be in the DOM in order to find the\n    // Hide it with opacity until it's ready to show.\n    this.popupEl.style.opacity = '0';\n\n    // Calculate position and add to DOM\n    this.options.rootElement.appendChild(this.popupEl);\n    await this.setPosition();\n\n    // Reset to the initial category and state\n    this.picker.reset(false);\n\n    // Picker is positioned and scrolled. \n    // Now we can show it with the animation.\n    await this.animatePopup(true);\n    await this.animateCloseButton(true);\n    this.picker.setInitialFocus();\n    this.externalEvents.emit('picker:open');\n  }\n\n  /**\n   * Closes the picker.\n   *\n   * @returns a Promise that resolves when the picker is finished closing\n   */\n  async close(): Promise<void> {\n    if (!this.isOpen) {\n      return;\n    }\n\n    await this.initiateOpenStateChange(false);\n    await this.animateCloseButton(false);\n    await this.animatePopup(false);\n\n    this.popupEl.remove();\n    this.picker.reset();\n    this.positionCleanup?.();\n\n    this.focusTrap.deactivate();\n    this.externalEvents.emit('picker:close');\n  }\n\n  /**\n   * Finds any pending (running) animations on the picker element.\n   *\n   * @returns an array of Animation objects that are in the 'running' state.\n   */\n  private getRunningAnimations(): Animation[] {\n    return this.picker.el.getAnimations().filter(animation => animation.playState === 'running');\n  }\n\n  /**\n   * Sets up the picker positioning.\n   */\n  private async setPosition() {\n    this.positionCleanup?.();\n      this.positionCleanup = await setPosition(\n        this,\n        this.popupEl,\n        this.referenceElement,\n        this.options.position as Position\n      );\n  }\n\n  /**\n   * Waits for all pending animations on the picker element to finish.\n   *\n   * @returns a Promise that resolves when all animations have finished\n   */\n  private awaitPendingAnimations(): Promise<Animation[]> {\n    return Promise.all(this.getRunningAnimations().map(animation => animation.finished));\n  }\n\n  /**\n   * Handles a click on the document, so that the picker is closed\n   * if the mouse is clicked outside of it.\n   *\n   * The picker will only be closed if:\n   * - The picker is currently open\n   * - The click target is not the trigger element or any of its children\n   * - The click target is not the picker or any of its children\n   *\n   * @param event The MouseEvent that was dispatched.\n   */\n  private onDocumentClick(event: MouseEvent) {\n    const clickedNode = event.target as Node;\n\n    const isClickOnTrigger = this.triggerElement?.contains(clickedNode);\n\n    if (this.isOpen && !this.picker.isPickerClick(event) && !isClickOnTrigger) {\n      this.close();\n    }\n  }\n\n  private animatePopup(openState: boolean) {\n    return animate(\n      this.popupEl,\n      {\n        opacity: [0, 1],\n        transform: ['scale(0.9)', 'scale(1)']\n      },\n      {\n        duration: 150,\n        id: openState ? 'show-picker' : 'hide-picker',\n        easing: 'ease-in-out',\n        direction: openState ? 'normal' : 'reverse',\n        fill: 'both'\n      },\n      this.options\n    );\n  }\n\n  private animateCloseButton(openState: boolean) {\n    if (this.closeButton) {\n      return animate(this.closeButton, {\n        opacity: [0, 1]\n      },\n      {\n        duration: 25,\n        id: openState ? 'show-close' : 'hide-close',\n        easing: 'ease-in-out',\n        direction: openState ? 'normal' : 'reverse',\n        fill: 'both',\n      },\n      this.options);\n    }\n  }\n\n  /**\n   * Prepares for an animation either for opening or closing the picker.\n   * If other animations are still running (this will happen when toggled rapidly), this will wait for them to finish.\n   *\n   * It will mark the new open state immediately then wait for pending animations to finish.\n   *\n   * @param openState The desired open state\n   */\n  private async initiateOpenStateChange(openState: boolean) {\n    this.isOpen = openState;\n    await this.awaitPendingAnimations();\n  }\n}\n","import { PickerOptions, createStyleInjector } from 'picmo';\nimport { PopupOptions } from './types';\nimport { PopupPickerController } from './popupPicker';\n\nimport css from './styles/index.css?inline';\n\nexport * from './types';\nexport { PopupPickerController };\n\nconst styleInject = createStyleInjector();\n\nexport function createPopup(pickerOptions: Partial<PickerOptions>, popupOptions: Partial<PopupOptions>) {\n  styleInject(css);\n\n  const popup = new PopupPickerController({\n    autoFocus: 'auto',\n    ...pickerOptions\n  }, popupOptions);\n  return popup;\n}\n"],"names":["getSide","placement","getAlignment","getMainAxisFromPlacement","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","commonY","mainAxis","length","commonAlign","side","isVertical","coords","computePosition","config","strategy","middleware","platform","rects","x","y","statefulPlacement","middlewareData","resetCount","i","name","fn","nextX","nextY","data","reset","expandPaddingObject","padding","getSideObjectFromPadding","rectToClientRect","rect","detectOverflow","middlewareArguments","options","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","elementClientRect","min","max","within","min$1","value","max$1","hash$1","getOppositePlacement","matched","getAlignmentSides","alignment","mainAlignmentSide","hash","getOppositeAlignmentPlacement","allPlacements","acc","getPlacementList","autoAlignment","allowedPlacements","autoPlacement","_middlewareData$autoP","_middlewareData$autoP2","_middlewareData$autoP3","_middlewareData$autoP4","_placementsSortedByLe","detectOverflowOptions","placements","overflow","currentIndex","currentPlacement","main","cross","currentOverflows","allOverflows","nextPlacement","placementsSortedByLeastOverflow","a","b","placementThatFitsOnAllSides","overflows","resetPlacement","getExpandedPlacements","oppositePlacement","flip","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","fallbackPlacements","overflowsData","_middlewareData$flip$","_middlewareData$flip2","nextIndex","_overflowsData$map$so","d","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","crossAxis","alignmentAxis","offset","diffCoords","getCrossAxis","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","isWindow","getWindow","node","ownerDocument","getComputedStyle","getNodeName","getUAString","uaData","item","isHTMLElement","isElement","isNode","isShadowRoot","OwnElement","isOverflowElement","overflowX","overflowY","isTableElement","isContainingBlock","isFirefox","css","isLayoutViewport","round","getBoundingClientRect","includeScale","isFixedStrategy","_win$visualViewport$o","_win$visualViewport","_win$visualViewport$o2","_win$visualViewport2","clientRect","scaleX","scaleY","win","addVisualOffsets","width","height","getDocumentElement","getNodeScroll","getWindowScrollBarX","isScaled","getRectRelativeToOffsetParent","offsetParent","isOffsetParentAnElement","documentElement","scroll","offsets","offsetRect","getParentNode","getTrueOffsetParent","composedOffsetParent","ancestor","foundInsideSlot","assignedSlot","newOffsetParent","hadStyleAttribute","oldDisplay","getContainingBlock","currentNode","parent","getOffsetParent","window","getDimensions","convertOffsetParentRelativeRectToViewportRelativeRect","getViewportRect","html","visualViewport","layoutViewport","getDocumentRect","_element$ownerDocumen","body","getNearestOverflowAncestor","parentNode","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","target","updatedList","contains","child","rootNode","next","getInnerBoundingClientRect","top","left","getClientRectFromClippingAncestor","clippingParent","getClippingAncestors","clippingAncestors","clipperElement","getClippingRect","firstClippingAncestor","clippingRect","accRect","clippingAncestor","autoUpdate","update","_ancestorScroll","_ancestorResize","elementResize","animationFrame","ancestorScroll","ancestorResize","ancestors","observer","initialUpdate","frameId","prevRefRect","frameLoop","nextRefRect","_observer","computePosition$1","setPosition","picker","pickerElement","referenceElement","position","setRelativePosition","setFixedPosition","handlePositionLost","key","defaultOptions","getOptions","closeIcon","classes","getPrefixedClasses","PopupPickerController","pickerOptions","popupOptions","Events","getPickerOptions","pickerContainer","createPicker","FocusTrap","_a","event","callback","triggerElement","animation","clickedNode","isClickOnTrigger","openState","animate","styleInject","createStyleInjector","createPopup"],"mappings":"qQAAA,SAASA,EAAQC,EAAW,CAC1B,OAAOA,EAAU,MAAM,GAAG,EAAE,EAC9B,CAEA,SAASC,EAAaD,EAAW,CAC/B,OAAOA,EAAU,MAAM,GAAG,EAAE,EAC9B,CAEA,SAASE,EAAyBF,EAAW,CAC3C,MAAO,CAAC,MAAO,QAAQ,EAAE,SAASD,EAAQC,CAAS,CAAC,EAAI,IAAM,GAChE,CAEA,SAASG,GAAkBC,EAAM,CAC/B,OAAOA,IAAS,IAAM,SAAW,OACnC,CAEA,SAASC,GAA2BC,EAAMN,EAAWO,EAAK,CACxD,GAAI,CACF,UAAAC,EACA,SAAAC,CACD,EAAGH,EACJ,MAAMI,EAAUF,EAAU,EAAIA,EAAU,MAAQ,EAAIC,EAAS,MAAQ,EAC/DE,EAAUH,EAAU,EAAIA,EAAU,OAAS,EAAIC,EAAS,OAAS,EACjEG,EAAWV,EAAyBF,CAAS,EAC7Ca,EAASV,GAAkBS,CAAQ,EACnCE,EAAcN,EAAUK,GAAU,EAAIJ,EAASI,GAAU,EACzDE,EAAOhB,EAAQC,CAAS,EACxBgB,EAAaJ,IAAa,IAChC,IAAIK,EAEJ,OAAQF,OACD,MACHE,EAAS,CACP,EAAGP,EACH,EAAGF,EAAU,EAAIC,EAAS,MAClC,EACM,UAEG,SACHQ,EAAS,CACP,EAAGP,EACH,EAAGF,EAAU,EAAIA,EAAU,MACnC,EACM,UAEG,QACHS,EAAS,CACP,EAAGT,EAAU,EAAIA,EAAU,MAC3B,EAAGG,CACX,EACM,UAEG,OACHM,EAAS,CACP,EAAGT,EAAU,EAAIC,EAAS,MAC1B,EAAGE,CACX,EACM,cAGAM,EAAS,CACP,EAAGT,EAAU,EACb,EAAGA,EAAU,CACrB,EAGE,OAAQP,EAAaD,CAAS,OACvB,QACHiB,EAAOL,IAAaE,GAAeP,GAAOS,EAAa,GAAK,GAC5D,UAEG,MACHC,EAAOL,IAAaE,GAAeP,GAAOS,EAAa,GAAK,GAC5D,MAGJ,OAAOC,CACT,CAUA,MAAMC,GAAkB,MAAOV,EAAWC,EAAUU,IAAW,CAC7D,KAAM,CACJ,UAAAnB,EAAY,SACZ,SAAAoB,EAAW,WACX,WAAAC,EAAa,CAAE,EACf,SAAAC,CACD,EAAGH,EACEZ,EAAM,MAAOe,EAAS,OAAS,KAAO,OAASA,EAAS,MAAMb,CAAQ,GAiB5E,IAAIc,EAAQ,MAAMD,EAAS,gBAAgB,CACzC,UAAAd,EACA,SAAAC,EACA,SAAAW,CACJ,CAAG,EACG,CACF,EAAAI,EACA,EAAAC,CACD,EAAGpB,GAA2BkB,EAAOvB,EAAWO,CAAG,EAChDmB,EAAoB1B,EACpB2B,EAAiB,CAAA,EACjBC,EAAa,EAEjB,QAASC,EAAI,EAAGA,EAAIR,EAAW,OAAQQ,IAAK,CAC1C,KAAM,CACJ,KAAAC,EACA,GAAAC,CACN,EAAQV,EAAWQ,GACT,CACJ,EAAGG,EACH,EAAGC,EACH,KAAAC,EACA,MAAAC,CACD,EAAG,MAAMJ,EAAG,CACX,EAAAP,EACA,EAAAC,EACA,iBAAkBzB,EAClB,UAAW0B,EACX,SAAAN,EACA,eAAAO,EACA,MAAAJ,EACA,SAAAD,EACA,SAAU,CACR,UAAAd,EACA,SAAAC,CACD,CACP,CAAK,EAeD,GAdAe,EAAIQ,GAAS,KAAOA,EAAQR,EAC5BC,EAAIQ,GAAS,KAAOA,EAAQR,EAC5BE,EAAiB,CAAE,GAAGA,EACpB,CAACG,GAAO,CAAE,GAAGH,EAAeG,GAC1B,GAAGI,CACJ,CACP,EAQQC,GAASP,GAAc,GAAI,CAC7BA,IAEI,OAAOO,GAAU,WACfA,EAAM,YACRT,EAAoBS,EAAM,WAGxBA,EAAM,QACRZ,EAAQY,EAAM,QAAU,GAAO,MAAMb,EAAS,gBAAgB,CAC5D,UAAAd,EACA,SAAAC,EACA,SAAAW,CACZ,CAAW,EAAIe,EAAM,OAGZ,CACC,EAAAX,EACA,EAAAC,CACD,EAAGpB,GAA2BkB,EAAOG,EAAmBnB,CAAG,GAG9DsB,EAAI,GACJ,QACD,CACF,CAED,MAAO,CACL,EAAAL,EACA,EAAAC,EACA,UAAWC,EACX,SAAAN,EACA,eAAAO,CACJ,CACA,EAEA,SAASS,GAAoBC,EAAS,CACpC,MAAO,CACL,IAAK,EACL,MAAO,EACP,OAAQ,EACR,KAAM,EACN,GAAGA,CACP,CACA,CAEA,SAASC,GAAyBD,EAAS,CACzC,OAAO,OAAOA,GAAY,SAAWD,GAAoBC,CAAO,EAAI,CAClE,IAAKA,EACL,MAAOA,EACP,OAAQA,EACR,KAAMA,CACV,CACA,CAEA,SAASE,EAAiBC,EAAM,CAC9B,MAAO,CAAE,GAAGA,EACV,IAAKA,EAAK,EACV,KAAMA,EAAK,EACX,MAAOA,EAAK,EAAIA,EAAK,MACrB,OAAQA,EAAK,EAAIA,EAAK,MAC1B,CACA,CAUA,eAAeC,EAAeC,EAAqBC,EAAS,CAC1D,IAAIC,EAEAD,IAAY,SACdA,EAAU,CAAA,GAGZ,KAAM,CACJ,EAAAnB,EACA,EAAAC,EACA,SAAAH,EACA,MAAAC,EACA,SAAAsB,EACA,SAAAzB,CACD,EAAGsB,EACE,CACJ,SAAAI,EAAW,oBACX,aAAAC,EAAe,WACf,eAAAC,EAAiB,WACjB,YAAAC,EAAc,GACd,QAAAZ,EAAU,CACX,EAAGM,EACEO,EAAgBZ,GAAyBD,CAAO,EAEhDc,EAAUN,EAASI,EADND,IAAmB,WAAa,YAAc,WACbA,GAC9CI,EAAqBb,EAAiB,MAAMjB,EAAS,gBAAgB,CACzE,SAAWsB,EAAwB,MAAOtB,EAAS,WAAa,KAAO,OAASA,EAAS,UAAU6B,CAAO,KAAO,MAAOP,EAAgCO,EAAUA,EAAQ,gBAAmB,MAAO7B,EAAS,oBAAsB,KAAO,OAASA,EAAS,mBAAmBuB,EAAS,QAAQ,GAChS,SAAAC,EACA,aAAAC,EACA,SAAA3B,CACD,CAAA,CAAC,EACIiC,EAAoBd,EAAiBjB,EAAS,sDAAwD,MAAMA,EAAS,sDAAsD,CAC/K,KAAM0B,IAAmB,WAAa,CAAE,GAAGzB,EAAM,SAC/C,EAAAC,EACA,EAAAC,CACD,EAAGF,EAAM,UACV,aAAc,MAAOD,EAAS,iBAAmB,KAAO,OAASA,EAAS,gBAAgBuB,EAAS,QAAQ,GAC3G,SAAAzB,CACJ,CAAG,EAAIG,EAAMyB,EAAe,EAC1B,MAAO,CACL,IAAKI,EAAmB,IAAMC,EAAkB,IAAMH,EAAc,IACpE,OAAQG,EAAkB,OAASD,EAAmB,OAASF,EAAc,OAC7E,KAAME,EAAmB,KAAOC,EAAkB,KAAOH,EAAc,KACvE,MAAOG,EAAkB,MAAQD,EAAmB,MAAQF,EAAc,KAC9E,CACA,CAEA,MAAMI,GAAM,KAAK,IACXC,GAAM,KAAK,IAEjB,SAASC,GAAOC,EAAOC,EAAOC,EAAO,CACnC,OAAOJ,GAAIE,EAAOH,GAAII,EAAOC,CAAK,CAAC,CACrC,CA2EA,MAAMC,GAAS,CACb,KAAM,QACN,MAAO,OACP,OAAQ,MACR,IAAK,QACP,EACA,SAASC,EAAqB7D,EAAW,CACvC,OAAOA,EAAU,QAAQ,yBAA0B8D,GAAWF,GAAOE,EAAQ,CAC/E,CAEA,SAASC,GAAkB/D,EAAWuB,EAAOhB,EAAK,CAC5CA,IAAQ,SACVA,EAAM,IAGR,MAAMyD,EAAY/D,EAAaD,CAAS,EAClCY,EAAWV,EAAyBF,CAAS,EAC7Ca,EAASV,GAAkBS,CAAQ,EACzC,IAAIqD,EAAoBrD,IAAa,IAAMoD,KAAezD,EAAM,MAAQ,SAAW,QAAU,OAASyD,IAAc,QAAU,SAAW,MAEzI,OAAIzC,EAAM,UAAUV,GAAUU,EAAM,SAASV,KAC3CoD,EAAoBJ,EAAqBI,CAAiB,GAGrD,CACL,KAAMA,EACN,MAAOJ,EAAqBI,CAAiB,CACjD,CACA,CAEA,MAAMC,GAAO,CACX,MAAO,MACP,IAAK,OACP,EACA,SAASC,EAA8BnE,EAAW,CAChD,OAAOA,EAAU,QAAQ,aAAc8D,GAAWI,GAAKJ,EAAQ,CACjE,CAGA,MAAMM,GADQ,CAAC,MAAO,QAAS,SAAU,MAAM,EACN,OAAO,CAACC,EAAKtD,IAASsD,EAAI,OAAOtD,EAAMA,EAAO,SAAUA,EAAO,MAAM,EAAG,CAAE,CAAA,EAEnH,SAASuD,GAAiBN,EAAWO,EAAeC,EAAmB,CAErE,OAD2CR,EAAY,CAAC,GAAGQ,EAAkB,OAAOxE,GAAaC,EAAaD,CAAS,IAAMgE,CAAS,EAAG,GAAGQ,EAAkB,OAAOxE,GAAaC,EAAaD,CAAS,IAAMgE,CAAS,CAAC,EAAIQ,EAAkB,OAAOxE,GAAaD,EAAQC,CAAS,IAAMA,CAAS,GACxP,OAAOA,GAC3CgE,EACK/D,EAAaD,CAAS,IAAMgE,IAAcO,EAAgBJ,EAA8BnE,CAAS,IAAMA,EAAY,IAGrH,EACR,CACH,CAMA,MAAMyE,GAAgB,SAAU9B,EAAS,CACvC,OAAIA,IAAY,SACdA,EAAU,CAAA,GAGL,CACL,KAAM,gBACN,QAAAA,EAEA,MAAM,GAAGD,EAAqB,CAC5B,IAAIgC,EAAuBC,EAAwBC,EAAwBC,EAAwBC,EAEnG,KAAM,CACJ,EAAAtD,EACA,EAAAC,EACA,MAAAF,EACA,eAAAI,EACA,UAAA3B,EACA,SAAAsB,EACA,SAAAuB,CACD,EAAGH,EACE,CACJ,UAAAsB,EAAY,KACZ,kBAAAQ,EAAoBJ,GACpB,cAAAG,EAAgB,MACbQ,CACJ,EAAGpC,EACEqC,EAAaV,GAAiBN,EAAWO,EAAeC,CAAiB,EACzES,EAAW,MAAMxC,EAAeC,EAAqBqC,CAAqB,EAC1EG,GAAgBR,GAAyBC,EAAyBhD,EAAe,gBAAkB,KAAO,OAASgD,EAAuB,QAAU,KAAOD,EAAwB,EACnLS,EAAmBH,EAAWE,GAEpC,GAAIC,GAAoB,KACtB,MAAO,GAGT,KAAM,CACJ,KAAAC,EACA,MAAAC,CACD,EAAGtB,GAAkBoB,EAAkB5D,EAAO,MAAOD,EAAS,OAAS,KAAO,OAASA,EAAS,MAAMuB,EAAS,QAAQ,EAAE,EAE1H,GAAI7C,IAAcmF,EAChB,MAAO,CACL,EAAA3D,EACA,EAAAC,EACA,MAAO,CACL,UAAWuD,EAAW,EACvB,CACX,EAGM,MAAMM,EAAmB,CAACL,EAASlF,EAAQoF,CAAgB,GAAIF,EAASG,GAAOH,EAASI,EAAM,EACxFE,EAAe,CAAC,IAAKX,GAA0BC,EAAyBlD,EAAe,gBAAkB,KAAO,OAASkD,EAAuB,YAAc,KAAOD,EAAyB,CAAA,EAAK,CACvM,UAAWO,EACX,UAAWG,CACnB,CAAO,EACKE,EAAgBR,EAAWE,EAAe,GAEhD,GAAIM,EACF,MAAO,CACL,KAAM,CACJ,MAAON,EAAe,EACtB,UAAWK,CACZ,EACD,MAAO,CACL,UAAWC,CACZ,CACX,EAGM,MAAMC,EAAkCF,EAAa,MAAO,EAAC,KAAK,CAACG,EAAGC,IAAMD,EAAE,UAAU,GAAKC,EAAE,UAAU,EAAE,EACrGC,GAA+Bd,EAAwBW,EAAgC,KAAKnF,GAAQ,CACxG,GAAI,CACF,UAAAuF,CACD,EAAGvF,EACJ,OAAOuF,EAAU,MAAMZ,IAAYA,IAAY,CAAC,CACjD,CAAA,IAAM,KAAO,OAASH,EAAsB,UACvCgB,EAAiBF,GAA+B,KAAOA,EAA8BH,EAAgC,GAAG,UAE9H,OAAIK,IAAmB9F,EACd,CACL,KAAM,CACJ,MAAOkF,EAAe,EACtB,UAAWK,CACZ,EACD,MAAO,CACL,UAAWO,CACZ,CACX,EAGa,EACR,CAEL,CACA,EAEA,SAASC,GAAsB/F,EAAW,CACxC,MAAMgG,EAAoBnC,EAAqB7D,CAAS,EACxD,MAAO,CAACmE,EAA8BnE,CAAS,EAAGgG,EAAmB7B,EAA8B6B,CAAiB,CAAC,CACvH,CAOA,MAAMC,GAAO,SAAUtD,EAAS,CAC9B,OAAIA,IAAY,SACdA,EAAU,CAAA,GAGL,CACL,KAAM,OACN,QAAAA,EAEA,MAAM,GAAGD,EAAqB,CAC5B,IAAIwD,EAEJ,KAAM,CACJ,UAAAlG,EACA,eAAA2B,EACA,MAAAJ,EACA,iBAAA4E,EACA,SAAA7E,EACA,SAAAuB,CACD,EAAGH,EACE,CACJ,SAAU0D,EAAgB,GAC1B,UAAWC,EAAiB,GAC5B,mBAAoBC,EACpB,iBAAAC,EAAmB,UACnB,cAAAC,EAAgB,MACbzB,CACJ,EAAGpC,EACE5B,EAAOhB,EAAQC,CAAS,EAExByG,EAAqBH,IADHvF,IAASoF,GAC6C,CAACK,EAAgB,CAAC3C,EAAqBsC,CAAgB,CAAC,EAAIJ,GAAsBI,CAAgB,GAC1KnB,EAAa,CAACmB,EAAkB,GAAGM,CAAkB,EACrDxB,EAAW,MAAMxC,EAAeC,EAAqBqC,CAAqB,EAC1Ec,EAAY,CAAA,EAClB,IAAIa,IAAkBR,EAAuBvE,EAAe,OAAS,KAAO,OAASuE,EAAqB,YAAc,CAAA,EAMxH,GAJIE,GACFP,EAAU,KAAKZ,EAASlE,EAAK,EAG3BsF,EAAgB,CAClB,KAAM,CACJ,KAAAjB,EACA,MAAAC,CACD,EAAGtB,GAAkB/D,EAAWuB,EAAO,MAAOD,EAAS,OAAS,KAAO,OAASA,EAAS,MAAMuB,EAAS,QAAQ,EAAE,EACnHgD,EAAU,KAAKZ,EAASG,GAAOH,EAASI,EAAM,CAC/C,CAOD,GALAqB,EAAgB,CAAC,GAAGA,EAAe,CACjC,UAAA1G,EACA,UAAA6F,CACR,CAAO,EAEG,CAACA,EAAU,MAAM9E,GAAQA,GAAQ,CAAC,EAAG,CACvC,IAAI4F,EAAuBC,EAE3B,MAAMC,IAAcF,GAAyBC,EAAwBjF,EAAe,OAAS,KAAO,OAASiF,EAAsB,QAAU,KAAOD,EAAwB,GAAK,EAC3KnB,EAAgBR,EAAW6B,GAEjC,GAAIrB,EAEF,MAAO,CACL,KAAM,CACJ,MAAOqB,EACP,UAAWH,CACZ,EACD,MAAO,CACL,UAAWlB,CACZ,CACb,EAGQ,IAAIM,EAAiB,SAErB,OAAQS,OACD,UACH,CACE,IAAIO,EAEJ,MAAM9G,GAAa8G,EAAwBJ,EAAc,IAAIK,GAAK,CAACA,EAAGA,EAAE,UAAU,OAAO9B,GAAYA,EAAW,CAAC,EAAE,OAAO,CAACZ,EAAKY,IAAaZ,EAAMY,EAAU,CAAC,CAAC,CAAC,EAAE,KAAK,CAACS,EAAGC,IAAMD,EAAE,GAAKC,EAAE,EAAE,EAAE,KAAO,KAAO,OAASmB,EAAsB,GAAG,UAE1O9G,IACF8F,EAAiB9F,GAGnB,KACD,KAEE,mBACH8F,EAAiBK,EACjB,MAGJ,GAAInG,IAAc8F,EAChB,MAAO,CACL,MAAO,CACL,UAAWA,CACZ,CACb,CAEO,CAED,MAAO,EACR,CAEL,CACA,EAwEA,eAAekB,GAAqBtE,EAAqBgB,EAAO,CAC9D,KAAM,CACJ,UAAA1D,EACA,SAAAsB,EACA,SAAAuB,CACD,EAAGH,EACEnC,EAAM,MAAOe,EAAS,OAAS,KAAO,OAASA,EAAS,MAAMuB,EAAS,QAAQ,GAC/E9B,EAAOhB,EAAQC,CAAS,EACxBgE,EAAY/D,EAAaD,CAAS,EAClCgB,EAAad,EAAyBF,CAAS,IAAM,IACrDiH,EAAgB,CAAC,OAAQ,KAAK,EAAE,SAASlG,CAAI,EAAI,GAAK,EACtDmG,EAAiB3G,GAAOS,EAAa,GAAK,EAC1CmG,EAAW,OAAOzD,GAAU,WAAaA,EAAMhB,CAAmB,EAAIgB,EAE5E,GAAI,CACF,SAAA9C,EACA,UAAAwG,EACA,cAAAC,CACJ,EAAM,OAAOF,GAAa,SAAW,CACjC,SAAUA,EACV,UAAW,EACX,cAAe,IACnB,EAAM,CACF,SAAU,EACV,UAAW,EACX,cAAe,KACf,GAAGA,CACP,EAEE,OAAInD,GAAa,OAAOqD,GAAkB,WACxCD,EAAYpD,IAAc,MAAQqD,EAAgB,GAAKA,GAGlDrG,EAAa,CAClB,EAAGoG,EAAYF,EACf,EAAGtG,EAAWqG,CAClB,EAAM,CACF,EAAGrG,EAAWqG,EACd,EAAGG,EAAYF,CACnB,CACA,CAMA,MAAMI,GAAS,SAAU5D,EAAO,CAC9B,OAAIA,IAAU,SACZA,EAAQ,GAGH,CACL,KAAM,SACN,QAASA,EAET,MAAM,GAAGhB,EAAqB,CAC5B,KAAM,CACJ,EAAAlB,EACA,EAAAC,CACD,EAAGiB,EACE6E,EAAa,MAAMP,GAAqBtE,EAAqBgB,CAAK,EACxE,MAAO,CACL,EAAGlC,EAAI+F,EAAW,EAClB,EAAG9F,EAAI8F,EAAW,EAClB,KAAMA,CACd,CACK,CAEL,CACA,EAEA,SAASC,GAAapH,EAAM,CAC1B,OAAOA,IAAS,IAAM,IAAM,GAC9B,CAOA,MAAMqH,GAAQ,SAAU9E,EAAS,CAC/B,OAAIA,IAAY,SACdA,EAAU,CAAA,GAGL,CACL,KAAM,QACN,QAAAA,EAEA,MAAM,GAAGD,EAAqB,CAC5B,KAAM,CACJ,EAAAlB,EACA,EAAAC,EACA,UAAAzB,CACD,EAAG0C,EACE,CACJ,SAAU0D,EAAgB,GAC1B,UAAWC,EAAiB,GAC5B,QAAAqB,EAAU,CACR,GAAIpH,GAAQ,CACV,GAAI,CACF,EAAAkB,EACA,EAAAC,CACD,EAAGnB,EACJ,MAAO,CACL,EAAAkB,EACA,EAAAC,CACd,CACW,CACF,KACEsD,CACJ,EAAGpC,EACE1B,EAAS,CACb,EAAAO,EACA,EAAAC,CACR,EACYwD,EAAW,MAAMxC,EAAeC,EAAqBqC,CAAqB,EAC1EnE,EAAWV,EAAyBH,EAAQC,CAAS,CAAC,EACtDoH,EAAYI,GAAa5G,CAAQ,EACvC,IAAI+G,EAAgB1G,EAAOL,GACvBgH,EAAiB3G,EAAOmG,GAE5B,GAAIhB,EAAe,CACjB,MAAMyB,EAAUjH,IAAa,IAAM,MAAQ,OACrCkH,EAAUlH,IAAa,IAAM,SAAW,QACxC0C,EAAMqE,EAAgB1C,EAAS4C,GAC/BtE,EAAMoE,EAAgB1C,EAAS6C,GACrCH,EAAgBnE,GAAOF,EAAKqE,EAAepE,CAAG,CAC/C,CAED,GAAI8C,EAAgB,CAClB,MAAMwB,EAAUT,IAAc,IAAM,MAAQ,OACtCU,EAAUV,IAAc,IAAM,SAAW,QACzC9D,EAAMsE,EAAiB3C,EAAS4C,GAChCtE,EAAMqE,EAAiB3C,EAAS6C,GACtCF,EAAiBpE,GAAOF,EAAKsE,EAAgBrE,CAAG,CACjD,CAED,MAAMwE,EAAgBL,EAAQ,GAAG,CAAE,GAAGhF,EACpC,CAAC9B,GAAW+G,EACZ,CAACP,GAAYQ,CACrB,CAAO,EACD,MAAO,CAAE,GAAGG,EACV,KAAM,CACJ,EAAGA,EAAc,EAAIvG,EACrB,EAAGuG,EAAc,EAAItG,CACtB,CACT,CACK,CAEL,CACA,ECl1BA,SAASuG,GAAStE,EAAO,CACvB,OAAOA,GAASA,EAAM,UAAYA,EAAM,UAAYA,EAAM,OAASA,EAAM,WAC3E,CACA,SAASuE,EAAUC,EAAM,CACvB,GAAIA,GAAQ,KACV,OAAO,OAGT,GAAI,CAACF,GAASE,CAAI,EAAG,CACnB,MAAMC,EAAgBD,EAAK,cAC3B,OAAOC,GAAgBA,EAAc,aAAe,MACrD,CAED,OAAOD,CACT,CAEA,SAASE,EAAiBjF,EAAS,CACjC,OAAO8E,EAAU9E,CAAO,EAAE,iBAAiBA,CAAO,CACpD,CAEA,SAASkF,EAAYH,EAAM,CACzB,OAAOF,GAASE,CAAI,EAAI,GAAKA,GAAQA,EAAK,UAAY,IAAI,YAAW,EAAK,EAC5E,CAEA,SAASI,IAAc,CACrB,MAAMC,EAAS,UAAU,cAEzB,OAAIA,GAAU,MAAQA,EAAO,OACpBA,EAAO,OAAO,IAAIC,GAAQA,EAAK,MAAQ,IAAMA,EAAK,OAAO,EAAE,KAAK,GAAG,EAGrE,UAAU,SACnB,CAEA,SAASC,EAAc/E,EAAO,CAC5B,OAAOA,aAAiBuE,EAAUvE,CAAK,EAAE,WAC3C,CACA,SAASgF,EAAUhF,EAAO,CACxB,OAAOA,aAAiBuE,EAAUvE,CAAK,EAAE,OAC3C,CACA,SAASiF,GAAOjF,EAAO,CACrB,OAAOA,aAAiBuE,EAAUvE,CAAK,EAAE,IAC3C,CACA,SAASkF,EAAaV,EAAM,CAE1B,GAAI,OAAO,WAAe,IACxB,MAAO,GAGT,MAAMW,EAAaZ,EAAUC,CAAI,EAAE,WACnC,OAAOA,aAAgBW,GAAcX,aAAgB,UACvD,CACA,SAASY,EAAkB3F,EAAS,CAElC,KAAM,CACJ,SAAA8B,EACA,UAAA8D,EACA,UAAAC,CACJ,EAAMZ,EAAiBjF,CAAO,EAC5B,MAAO,6BAA6B,KAAK8B,EAAW+D,EAAYD,CAAS,CAC3E,CACA,SAASE,GAAe9F,EAAS,CAC/B,MAAO,CAAC,QAAS,KAAM,IAAI,EAAE,SAASkF,EAAYlF,CAAO,CAAC,CAC5D,CACA,SAAS+F,GAAkB/F,EAAS,CAElC,MAAMgG,EAAY,WAAW,KAAKb,GAAa,CAAA,EACzCc,EAAMhB,EAAiBjF,CAAO,EAIpC,OAAOiG,EAAI,YAAc,QAAUA,EAAI,cAAgB,QACvDA,EAAI,UAAY,SAAW,CAAC,YAAa,aAAa,EAAE,SAASA,EAAI,UAAU,GAAKD,GAAaC,EAAI,aAAe,UAAYD,IAAcC,EAAI,OAASA,EAAI,SAAW,OAAS,GACrL,CACA,SAASC,IAAmB,CAE1B,MAAO,CAAC,iCAAiC,KAAKf,GAAa,CAAA,CAK7D,CAEA,MAAMhF,GAAM,KAAK,IACXC,EAAM,KAAK,IACX+F,EAAQ,KAAK,MAEnB,SAASC,EAAsBpG,EAASqG,EAAcC,EAAiB,CACrE,IAAIC,EAAuBC,EAAqBC,EAAwBC,EAEpEL,IAAiB,SACnBA,EAAe,IAGbC,IAAoB,SACtBA,EAAkB,IAGpB,MAAMK,EAAa3G,EAAQ,wBAC3B,IAAI4G,EAAS,EACTC,EAAS,EAETR,GAAgBf,EAActF,CAAO,IACvC4G,EAAS5G,EAAQ,YAAc,GAAImG,EAAMQ,EAAW,KAAK,EAAI3G,EAAQ,aAAe,EACpF6G,EAAS7G,EAAQ,aAAe,GAAImG,EAAMQ,EAAW,MAAM,EAAI3G,EAAQ,cAAgB,GAGzF,MAAM8G,EAAMvB,EAAUvF,CAAO,EAAI8E,EAAU9E,CAAO,EAAI,OAChD+G,EAAmB,CAACb,GAAkB,GAAII,EAC1CjI,GAAKsI,EAAW,MAAQI,IAAoBR,GAAyBC,EAAsBM,EAAI,iBAAmB,KAAO,OAASN,EAAoB,aAAe,KAAOD,EAA4B,IAAMK,EAC9MtI,GAAKqI,EAAW,KAAOI,IAAoBN,GAA0BC,EAAuBI,EAAI,iBAAmB,KAAO,OAASJ,EAAqB,YAAc,KAAOD,EAA6B,IAAMI,EAChNG,EAAQL,EAAW,MAAQC,EAC3BK,EAASN,EAAW,OAASE,EACnC,MAAO,CACL,MAAAG,EACA,OAAAC,EACA,IAAK3I,EACL,MAAOD,EAAI2I,EACX,OAAQ1I,EAAI2I,EACZ,KAAM5I,EACN,EAAAA,EACA,EAAAC,CACJ,CACA,CAEA,SAAS4I,EAAmBnC,EAAM,CAChC,QAASS,GAAOT,CAAI,EAAIA,EAAK,cAAgBA,EAAK,WAAa,OAAO,UAAU,eAClF,CAEA,SAASoC,EAAcnH,EAAS,CAC9B,OAAIuF,EAAUvF,CAAO,EACZ,CACL,WAAYA,EAAQ,WACpB,UAAWA,EAAQ,SACzB,EAGS,CACL,WAAYA,EAAQ,YACpB,UAAWA,EAAQ,WACvB,CACA,CAEA,SAASoH,GAAoBpH,EAAS,CAGpC,OAAOoG,EAAsBc,EAAmBlH,CAAO,CAAC,EAAE,KAAOmH,EAAcnH,CAAO,EAAE,UAC1F,CAEA,SAASqH,GAASrH,EAAS,CACzB,MAAMX,EAAO+G,EAAsBpG,CAAO,EAC1C,OAAOmG,EAAM9G,EAAK,KAAK,IAAMW,EAAQ,aAAemG,EAAM9G,EAAK,MAAM,IAAMW,EAAQ,YACrF,CAEA,SAASsH,GAA8BtH,EAASuH,EAActJ,EAAU,CACtE,MAAMuJ,EAA0BlC,EAAciC,CAAY,EACpDE,EAAkBP,EAAmBK,CAAY,EACjDlI,EAAO+G,EAAsBpG,EACnCwH,GAA2BH,GAASE,CAAY,EAAGtJ,IAAa,OAAO,EACvE,IAAIyJ,EAAS,CACX,WAAY,EACZ,UAAW,CACf,EACE,MAAMC,EAAU,CACd,EAAG,EACH,EAAG,CACP,EAEE,GAAIH,GAA2B,CAACA,GAA2BvJ,IAAa,QAKtE,IAJIiH,EAAYqC,CAAY,IAAM,QAAU5B,EAAkB8B,CAAe,KAC3EC,EAASP,EAAcI,CAAY,GAGjCjC,EAAciC,CAAY,EAAG,CAC/B,MAAMK,EAAaxB,EAAsBmB,EAAc,EAAI,EAC3DI,EAAQ,EAAIC,EAAW,EAAIL,EAAa,WACxCI,EAAQ,EAAIC,EAAW,EAAIL,EAAa,SACzC,MAAUE,IACTE,EAAQ,EAAIP,GAAoBK,CAAe,GAInD,MAAO,CACL,EAAGpI,EAAK,KAAOqI,EAAO,WAAaC,EAAQ,EAC3C,EAAGtI,EAAK,IAAMqI,EAAO,UAAYC,EAAQ,EACzC,MAAOtI,EAAK,MACZ,OAAQA,EAAK,MACjB,CACA,CAEA,SAASwI,GAAc9C,EAAM,CAC3B,OAAIG,EAAYH,CAAI,IAAM,OACjBA,EAKPA,EAAK,cACLA,EAAK,aACLU,EAAaV,CAAI,EAAIA,EAAK,KAAO,OACjCmC,EAAmBnC,CAAI,CAG3B,CAEA,SAAS+C,GAAoB9H,EAAS,CACpC,MAAI,CAACsF,EAActF,CAAO,GAAKiF,EAAiBjF,CAAO,EAAE,WAAa,QAC7D,KAGF+H,GAAqB/H,CAAO,CACrC,CAOA,SAAS+H,GAAqB/H,EAAS,CACrC,GAAI,CACF,aAAAuH,CACD,EAAGvH,EACAgI,EAAWhI,EACXiI,EAAkB,GAEtB,KAAOD,GAAYA,IAAaT,GAAc,CAC5C,KAAM,CACJ,aAAAW,CACD,EAAGF,EAEJ,GAAIE,EAAc,CAChB,IAAIC,EAAkBD,EAAa,aAEnC,GAAIjD,EAAiBiD,CAAY,EAAE,UAAY,WAAY,CACzD,MAAME,EAAoBF,EAAa,aAAa,OAAO,EACrDG,EAAaH,EAAa,MAAM,QACtCA,EAAa,MAAM,QAAUjD,EAAiB+C,CAAQ,EAAE,QACxDG,EAAkBD,EAAa,aAC/BA,EAAa,MAAM,QAAUG,EAExBD,GACHF,EAAa,gBAAgB,OAAO,CAEvC,CAEDF,EAAWE,EAEPX,IAAiBY,IACnBZ,EAAeY,EACfF,EAAkB,GAE1B,SAAexC,EAAauC,CAAQ,GAAKA,EAAS,MAAQC,EACpD,MAGFD,EAAWvC,EAAauC,CAAQ,GAAKA,EAAS,MAAQA,EAAS,UAChE,CAED,OAAOT,CACT,CAEA,SAASe,GAAmBtI,EAAS,CACnC,IAAIuI,EAAcV,GAAc7H,CAAO,EAMvC,IAJIyF,EAAa8C,CAAW,IAC1BA,EAAcA,EAAY,MAGrBjD,EAAciD,CAAW,GAAK,CAAC,CAAC,OAAQ,MAAM,EAAE,SAASrD,EAAYqD,CAAW,CAAC,GAAG,CACzF,GAAIxC,GAAkBwC,CAAW,EAC/B,OAAOA,EACF,CACL,MAAMC,EAASD,EAAY,WAC3BA,EAAc9C,EAAa+C,CAAM,EAAIA,EAAO,KAAOA,CACpD,CACF,CAED,OAAO,IACT,CAIA,SAASC,GAAgBzI,EAAS,CAChC,MAAM0I,EAAS5D,EAAU9E,CAAO,EAChC,IAAIuH,EAAeO,GAAoB9H,CAAO,EAE9C,KAAOuH,GAAgBzB,GAAeyB,CAAY,GAAKtC,EAAiBsC,CAAY,EAAE,WAAa,UACjGA,EAAeO,GAAoBP,CAAY,EAGjD,OAAIA,IAAiBrC,EAAYqC,CAAY,IAAM,QAAUrC,EAAYqC,CAAY,IAAM,QAAUtC,EAAiBsC,CAAY,EAAE,WAAa,UAAY,CAACxB,GAAkBwB,CAAY,GACnLmB,EAGFnB,GAAgBe,GAAmBtI,CAAO,GAAK0I,CACxD,CAEA,SAASC,GAAc3I,EAAS,CAC9B,GAAIsF,EAActF,CAAO,EACvB,MAAO,CACL,MAAOA,EAAQ,YACf,OAAQA,EAAQ,YACtB,EAGE,MAAMX,EAAO+G,EAAsBpG,CAAO,EAC1C,MAAO,CACL,MAAOX,EAAK,MACZ,OAAQA,EAAK,MACjB,CACA,CAEA,SAASuJ,GAAsDzL,EAAM,CACnE,GAAI,CACF,KAAAkC,EACA,aAAAkI,EACA,SAAAtJ,CACD,EAAGd,EACJ,MAAMqK,EAA0BlC,EAAciC,CAAY,EACpDE,EAAkBP,EAAmBK,CAAY,EAEvD,GAAIA,IAAiBE,EACnB,OAAOpI,EAGT,IAAIqI,EAAS,CACX,WAAY,EACZ,UAAW,CACf,EACE,MAAMC,EAAU,CACd,EAAG,EACH,EAAG,CACP,EAEE,IAAIH,GAA2B,CAACA,GAA2BvJ,IAAa,YAClEiH,EAAYqC,CAAY,IAAM,QAAU5B,EAAkB8B,CAAe,KAC3EC,EAASP,EAAcI,CAAY,GAGjCjC,EAAciC,CAAY,GAAG,CAC/B,MAAMK,EAAaxB,EAAsBmB,EAAc,EAAI,EAC3DI,EAAQ,EAAIC,EAAW,EAAIL,EAAa,WACxCI,EAAQ,EAAIC,EAAW,EAAIL,EAAa,SACzC,CAOH,MAAO,CAAE,GAAGlI,EACV,EAAGA,EAAK,EAAIqI,EAAO,WAAaC,EAAQ,EACxC,EAAGtI,EAAK,EAAIqI,EAAO,UAAYC,EAAQ,CAC3C,CACA,CAEA,SAASkB,GAAgB7I,EAAS/B,EAAU,CAC1C,MAAM6I,EAAMhC,EAAU9E,CAAO,EACvB8I,EAAO5B,EAAmBlH,CAAO,EACjC+I,EAAiBjC,EAAI,eAC3B,IAAIE,EAAQ8B,EAAK,YACb7B,EAAS6B,EAAK,aACdzK,EAAI,EACJC,EAAI,EAER,GAAIyK,EAAgB,CAClB/B,EAAQ+B,EAAe,MACvB9B,EAAS8B,EAAe,OACxB,MAAMC,EAAiB9C,MAEnB8C,GAAkB,CAACA,GAAkB/K,IAAa,WACpDI,EAAI0K,EAAe,WACnBzK,EAAIyK,EAAe,UAEtB,CAED,MAAO,CACL,MAAA/B,EACA,OAAAC,EACA,EAAA5I,EACA,EAAAC,CACJ,CACA,CAIA,SAAS2K,GAAgBjJ,EAAS,CAChC,IAAIkJ,EAEJ,MAAMJ,EAAO5B,EAAmBlH,CAAO,EACjC0H,EAASP,EAAcnH,CAAO,EAC9BmJ,GAAQD,EAAwBlJ,EAAQ,gBAAkB,KAAO,OAASkJ,EAAsB,KAChGlC,EAAQ5G,EAAI0I,EAAK,YAAaA,EAAK,YAAaK,EAAOA,EAAK,YAAc,EAAGA,EAAOA,EAAK,YAAc,CAAC,EACxGlC,EAAS7G,EAAI0I,EAAK,aAAcA,EAAK,aAAcK,EAAOA,EAAK,aAAe,EAAGA,EAAOA,EAAK,aAAe,CAAC,EACnH,IAAI9K,EAAI,CAACqJ,EAAO,WAAaN,GAAoBpH,CAAO,EACxD,MAAM1B,EAAI,CAACoJ,EAAO,UAElB,OAAIzC,EAAiBkE,GAAQL,CAAI,EAAE,YAAc,QAC/CzK,GAAK+B,EAAI0I,EAAK,YAAaK,EAAOA,EAAK,YAAc,CAAC,EAAInC,GAGrD,CACL,MAAAA,EACA,OAAAC,EACA,EAAA5I,EACA,EAAAC,CACJ,CACA,CAEA,SAAS8K,GAA2BrE,EAAM,CACxC,MAAMsE,EAAaxB,GAAc9C,CAAI,EAErC,MAAI,CAAC,OAAQ,OAAQ,WAAW,EAAE,SAASG,EAAYmE,CAAU,CAAC,EAEzDtE,EAAK,cAAc,KAGxBO,EAAc+D,CAAU,GAAK1D,EAAkB0D,CAAU,EACpDA,EAGFD,GAA2BC,CAAU,CAC9C,CAEA,SAASC,EAAqBvE,EAAMwE,EAAM,CACxC,IAAIC,EAEAD,IAAS,SACXA,EAAO,CAAA,GAGT,MAAME,EAAqBL,GAA2BrE,CAAI,EACpD2E,EAASD,MAAyBD,EAAsBzE,EAAK,gBAAkB,KAAO,OAASyE,EAAoB,MACnH1C,EAAMhC,EAAU2E,CAAkB,EAClCE,EAASD,EAAS,CAAC5C,CAAG,EAAE,OAAOA,EAAI,gBAAkB,CAAA,EAAInB,EAAkB8D,CAAkB,EAAIA,EAAqB,CAAE,CAAA,EAAIA,EAC5HG,EAAcL,EAAK,OAAOI,CAAM,EACtC,OAAOD,EAASE,EAChBA,EAAY,OAAON,EAAqBK,CAAM,CAAC,CACjD,CAEA,SAASE,GAASrB,EAAQsB,EAAO,CAC/B,MAAMC,EAAWD,EAAM,aAAe,KAAO,OAASA,EAAM,cAE5D,GAAItB,EAAO,SAASsB,CAAK,EACvB,MAAO,GAEJ,GAAIC,GAAYtE,EAAasE,CAAQ,EAAG,CAC3C,IAAIC,EAAOF,EAEX,EAAG,CAED,GAAIE,GAAQxB,IAAWwB,EACrB,MAAO,GAITA,EAAOA,EAAK,YAAcA,EAAK,IAChC,OAAQA,EACV,CAED,MAAO,EACT,CAEA,SAASC,GAA2BjK,EAAS/B,EAAU,CACrD,MAAM0I,EAAaP,EAAsBpG,EAAS,GAAO/B,IAAa,OAAO,EACvEiM,EAAMvD,EAAW,IAAM3G,EAAQ,UAC/BmK,EAAOxD,EAAW,KAAO3G,EAAQ,WACvC,MAAO,CACL,IAAAkK,EACA,KAAAC,EACA,EAAGA,EACH,EAAGD,EACH,MAAOC,EAAOnK,EAAQ,YACtB,OAAQkK,EAAMlK,EAAQ,aACtB,MAAOA,EAAQ,YACf,OAAQA,EAAQ,YACpB,CACA,CAEA,SAASoK,GAAkCpK,EAASqK,EAAgBpM,EAAU,CAC5E,OAAIoM,IAAmB,WACdjL,EAAiByJ,GAAgB7I,EAAS/B,CAAQ,CAAC,EAGxDsH,EAAU8E,CAAc,EACnBJ,GAA2BI,EAAgBpM,CAAQ,EAGrDmB,EAAiB6J,GAAgB/B,EAAmBlH,CAAO,CAAC,CAAC,CACtE,CAKA,SAASsK,GAAqBtK,EAAS,CACrC,MAAMuK,EAAoBjB,EAAqBtJ,CAAO,EAEhDwK,EADoB,CAAC,WAAY,OAAO,EAAE,SAASvF,EAAiBjF,CAAO,EAAE,QAAQ,GAC/CsF,EAActF,CAAO,EAAIyI,GAAgBzI,CAAO,EAAIA,EAEhG,OAAKuF,EAAUiF,CAAc,EAKtBD,EAAkB,OAAOA,GAAqBhF,EAAUgF,CAAiB,GAAKV,GAASU,EAAmBC,CAAc,GAAKtF,EAAYqF,CAAiB,IAAM,MAAM,EAJpK,EAKX,CAIA,SAASE,GAAgBtN,EAAM,CAC7B,GAAI,CACF,QAAA6C,EACA,SAAAL,EACA,aAAAC,EACA,SAAA3B,CACD,EAAGd,EAEJ,MAAMoN,EAAoB,CAAC,GADG5K,IAAa,oBAAsB2K,GAAqBtK,CAAO,EAAI,CAAE,EAAC,OAAOL,CAAQ,EAC9DC,CAAY,EAC3D8K,EAAwBH,EAAkB,GAC1CI,EAAeJ,EAAkB,OAAO,CAACK,EAASC,IAAqB,CAC3E,MAAMxL,EAAO+K,GAAkCpK,EAAS6K,EAAkB5M,CAAQ,EAClF,OAAA2M,EAAQ,IAAMxK,EAAIf,EAAK,IAAKuL,EAAQ,GAAG,EACvCA,EAAQ,MAAQzK,GAAId,EAAK,MAAOuL,EAAQ,KAAK,EAC7CA,EAAQ,OAASzK,GAAId,EAAK,OAAQuL,EAAQ,MAAM,EAChDA,EAAQ,KAAOxK,EAAIf,EAAK,KAAMuL,EAAQ,IAAI,EACnCA,CACR,EAAER,GAAkCpK,EAAS0K,EAAuBzM,CAAQ,CAAC,EAC9E,MAAO,CACL,MAAO0M,EAAa,MAAQA,EAAa,KACzC,OAAQA,EAAa,OAASA,EAAa,IAC3C,EAAGA,EAAa,KAChB,EAAGA,EAAa,GACpB,CACA,CAEA,MAAMxM,GAAW,CACf,gBAAAsM,GACA,sDAAA7B,GACA,UAAArD,EACA,cAAAoD,GACA,gBAAAF,GACA,mBAAAvB,EACA,gBAAiB/J,GAAQ,CACvB,GAAI,CACF,UAAAE,EACA,SAAAC,EACA,SAAAW,CACD,EAAGd,EACJ,MAAO,CACL,UAAWmK,GAA8BjK,EAAWoL,GAAgBnL,CAAQ,EAAGW,CAAQ,EACvF,SAAU,CAAE,GAAG0K,GAAcrL,CAAQ,EACnC,EAAG,EACH,EAAG,CACJ,CACP,CACG,EACD,eAAgB0C,GAAW,MAAM,KAAKA,EAAQ,eAAc,CAAE,EAC9D,MAAOA,GAAWiF,EAAiBjF,CAAO,EAAE,YAAc,KAC5D,EAMA,SAAS8K,GAAWzN,EAAWC,EAAUyN,EAAQvL,EAAS,CACpDA,IAAY,SACdA,EAAU,CAAA,GAGZ,KAAM,CACJ,eAAgBwL,EAAkB,GAClC,eAAgBC,EAAkB,GAClC,cAAAC,EAAgB,GAChB,eAAAC,EAAiB,EAClB,EAAG3L,EACE4L,EAAiBJ,GAAmB,CAACG,EACrCE,EAAiBJ,GAAmB,CAACE,EACrCG,EAAYF,GAAkBC,EAAiB,CAAC,GAAI9F,EAAUlI,CAAS,EAAIiM,EAAqBjM,CAAS,EAAI,CAAE,EAAG,GAAGiM,EAAqBhM,CAAQ,CAAC,EAAI,GAC7JgO,EAAU,QAAQtD,GAAY,CAC5BoD,GAAkBpD,EAAS,iBAAiB,SAAU+C,EAAQ,CAC5D,QAAS,EACf,CAAK,EACDM,GAAkBrD,EAAS,iBAAiB,SAAU+C,CAAM,CAChE,CAAG,EACD,IAAIQ,EAAW,KAEf,GAAIL,EAAe,CACjB,IAAIM,EAAgB,GACpBD,EAAW,IAAI,eAAe,IAAM,CAC7BC,GACHT,IAGFS,EAAgB,EACtB,CAAK,EACDjG,EAAUlI,CAAS,GAAK,CAAC8N,GAAkBI,EAAS,QAAQlO,CAAS,EACrEkO,EAAS,QAAQjO,CAAQ,CAC1B,CAED,IAAImO,EACAC,EAAcP,EAAiB/E,EAAsB/I,CAAS,EAAI,KAElE8N,GACFQ,IAGF,SAASA,GAAY,CACnB,MAAMC,EAAcxF,EAAsB/I,CAAS,EAE/CqO,IAAgBE,EAAY,IAAMF,EAAY,GAAKE,EAAY,IAAMF,EAAY,GAAKE,EAAY,QAAUF,EAAY,OAASE,EAAY,SAAWF,EAAY,SACtKX,IAGFW,EAAcE,EACdH,EAAU,sBAAsBE,CAAS,CAC1C,CAED,OAAAZ,IACO,IAAM,CACX,IAAIc,EAEJP,EAAU,QAAQtD,GAAY,CAC5BoD,GAAkBpD,EAAS,oBAAoB,SAAU+C,CAAM,EAC/DM,GAAkBrD,EAAS,oBAAoB,SAAU+C,CAAM,CACrE,CAAK,GACAc,EAAYN,IAAa,MAAgBM,EAAU,aACpDN,EAAW,KAEPJ,GACF,qBAAqBM,CAAO,CAElC,CACA,CAQA,MAAM1N,GAAkB,CAACV,EAAWC,EAAUkC,IAAYsM,GAAkBzO,EAAWC,EAAU,CAC/F,SAAAa,GACA,GAAGqB,CACL,CAAC,EChoBD,eAAsBuM,GAAYC,EAA+BC,EAA4BC,EAA2CC,EAA8C,CACpL,GAAI,CAACA,EACG,MAAA,IAAI,MAAM,mCAAmC,EAGrD,OAAO,MAAO,OAAOA,GAAa,SAChCC,GAAoBJ,EAAQC,EAAeC,EAAkBC,CAAQ,EACrEE,GAAiBJ,EAAeE,CAAQ,EAC5C,CAEA,eAAeC,GAAoBJ,EAA+BC,EAA4BC,EAA2CrP,EAAuD,CAC9L,GAAI,CAACqP,EACG,MAAA,IAAI,MAAM,wDAAwD,EAGtE,IAAAlO,EAEJ,OAAInB,IAAc,OACPmB,EAAA,CACP,WAAY,CACVsD,GAAc,EACdgD,GAAM,EACNH,GAAO,CAAE,SAAU,EAAG,UAAW,GAAI,CACvC,CAAA,EAGOnG,EAAA,CACP,UAAAnB,EACA,WAAY,CACViG,GAAK,EACLwB,GAAM,EACNH,GAAO,CAAC,CACV,CAAA,EAIG2G,GAAWoB,EAAkBD,EAAe,SAAY,CAC7D,IAAI,CAACC,EAAiB,aAAe,CAACA,EAAiB,eACjDI,GAAmBN,CAAM,EAC3B,OAIE,KAAA,CAAE,EAAA3N,EAAG,EAAAC,GAAM,MAAMP,GAAgBmO,EAAkBD,EAAejO,CAAM,EACvE,OAAA,OAAOiO,EAAc,MAAO,CACjC,SAAU,WACV,KAAM,GAAG5N,MACT,IAAK,GAAGC,KAAA,CACT,CAAA,CACF,CACH,CAEA,SAAS+N,GAAiBL,EAAqBG,EAA0C,CACvF,OAAAH,EAAO,MAAM,SAAW,QAEjB,OAAA,QAAQG,CAAQ,EAAE,QAAQ,CAAC,CAACI,EAAKhM,CAAK,IAAM,CACjDyL,EAAO,MAAMO,GAAOhM,CAAA,CACrB,EAGM,IAAM,CAAA,CACf,CAEA,SAAS+L,GAAmBN,EAA+B,CACzD,OAAQA,EAAO,QAAQ,oBAChB,QACH,OAAAA,EAAO,MAAM,EACN,OACJ,UACH,OAAAA,EAAO,QAAQ,EACR,OACJ,OACI,MAAA,GAEb,CC9EA,MAAMQ,GAAwC,CAC5C,mBAAoB,GACpB,kBAAmB,GACnB,aAAc,GACd,SAAU,OACV,gBAAiB,GACjB,eAAgB,MAClB,EAEgB,SAAAC,GAAWjN,EAAiC,GAAkB,CACrE,MAAA,CACL,GAAGgN,GACH,YAAa,SAAS,KACtB,GAAGhN,CAAA,CAEP,CCjBe,MAAAkN,GAAA,6mBCwBTC,GAAUC,EAAA,mBACd,iBACA,aACF,EAEO,MAAMC,EAAsB,CAejC,YAAYC,EAAuCC,EAAqC,CAb/E,KAAA,OAAA,GAWD,KAAA,eAAiB,IAAIC,EAAAA,OAGtB,KAAA,QAAU,CAAE,GAAGP,GAAWM,CAAY,EAAG,GAAGE,EAAAA,WAAiBH,CAAa,GAE1E,KAAA,QAAU,SAAS,cAAc,KAAK,EAC3C,KAAK,QAAQ,UAAU,IAAIH,GAAQ,cAAc,EACjD,KAAK,QAAQ,UAAU,IAAI,KAAK,QAAQ,KAAK,EAEzCI,EAAa,WACf,KAAK,QAAQ,UAAU,IAAIA,EAAa,SAAS,EAG/C,KAAK,QAAQ,kBACV,KAAA,YAAc,SAAS,cAAc,QAAQ,EAClD,KAAK,YAAY,KAAO,SACxB,KAAK,YAAY,UAAU,IAAIJ,GAAQ,WAAW,EAClD,KAAK,YAAY,UAAYD,GACxB,KAAA,YAAY,iBAAiB,QAAS,IAAM,CAC/C,KAAK,MAAM,CAAA,CACZ,EACI,KAAA,QAAQ,YAAY,KAAK,WAAW,GAGrC,MAAAQ,EAAkB,SAAS,cAAc,KAAK,EAC/C,KAAA,QAAQ,YAAYA,CAAe,EAEnC,KAAA,OAASC,EAAAA,aAAa,CAAE,GAAG,KAAK,QAAS,YAAaD,EAAiB,EACvE,KAAA,UAAY,IAAIE,EAAAA,UAEhB,KAAA,OAAO,iBAAiB,aAAc,IAAM,CAC/C,KAAK,UAAU,SAAS,KAAK,OAAO,EAAE,EACtC,KAAK,OAAO,iBAAgB,CAC7B,EAEG,KAAK,QAAQ,mBACV,KAAA,OAAO,iBAAiB,eAAgB,IAAM,OACjD,KAAK,MAAM,GACXC,EAAA,KAAK,iBAAL,MAAAA,EAAqB,OAAM,CAC5B,EAGC,KAAK,QAAQ,qBACf,KAAK,gBAAkB,KAAK,gBAAgB,KAAK,IAAI,EAC5C,SAAA,iBAAiB,QAAS,KAAK,eAAe,GAGrD,KAAK,QAAQ,eACf,KAAK,cAAgB,KAAK,cAAc,KAAK,IAAI,EACjD,KAAK,QAAQ,iBAAiB,UAAW,KAAK,aAAa,GAGxD,KAAA,iBAAmB,KAAK,QAAQ,iBAChC,KAAA,eAAiB,KAAK,QAAQ,cACrC,CAQA,iBAAiBC,EAAmBC,EAAyB,CACtD,KAAA,eAAe,GAAGD,EAAOC,CAAQ,EACjC,KAAA,OAAO,iBAAiBD,EAAwBC,CAAQ,CAC/D,CAEA,oBAAoBD,EAAmBC,EAAyB,CACzD,KAAA,eAAe,IAAID,EAAOC,CAAQ,EAClC,KAAA,OAAO,oBAAoBD,EAAwBC,CAAQ,CAClE,CAEQ,cAAcD,EAAsB,OACtCA,EAAM,MAAQ,WAChB,KAAK,MAAM,GACXD,EAAA,KAAK,iBAAL,MAAAA,EAAqB,QAEzB,CAUA,MAAM,SAAU,CACV,KAAK,QACP,MAAM,KAAK,QAGJ,SAAA,oBAAoB,QAAS,KAAK,eAAe,EAE1D,KAAK,OAAO,UACZ,KAAK,eAAe,WACtB,CAQA,OAAO7N,EAAsC,CAC3C,OAAO,KAAK,OAAS,KAAK,MAAU,EAAA,KAAK,KAAKA,CAAO,CACvD,CAOA,MAAM,KAAK,CAAE,eAAAgO,EAAgB,iBAAAtB,CAAiB,EAAiB,CAAA,EAAmB,CAC5E,KAAK,SAILsB,IACF,KAAK,eAAiBA,GAGpBtB,IACF,KAAK,iBAAmBA,GAGpB,MAAA,KAAK,wBAAwB,EAAI,EAIlC,KAAA,QAAQ,MAAM,QAAU,IAG7B,KAAK,QAAQ,YAAY,YAAY,KAAK,OAAO,EACjD,MAAM,KAAK,cAGN,KAAA,OAAO,MAAM,EAAK,EAIjB,MAAA,KAAK,aAAa,EAAI,EACtB,MAAA,KAAK,mBAAmB,EAAI,EAClC,KAAK,OAAO,kBACP,KAAA,eAAe,KAAK,aAAa,EACxC,CAOA,MAAM,OAAuB,OACvB,CAAC,KAAK,SAIJ,MAAA,KAAK,wBAAwB,EAAK,EAClC,MAAA,KAAK,mBAAmB,EAAK,EAC7B,MAAA,KAAK,aAAa,EAAK,EAE7B,KAAK,QAAQ,SACb,KAAK,OAAO,SACZmB,EAAA,KAAK,kBAAL,MAAAA,EAAA,WAEA,KAAK,UAAU,aACV,KAAA,eAAe,KAAK,cAAc,EACzC,CAOQ,sBAAoC,CACnC,OAAA,KAAK,OAAO,GAAG,gBAAgB,OAAOI,GAAaA,EAAU,YAAc,SAAS,CAC7F,CAKA,MAAc,aAAc,QAC1BJ,EAAA,KAAK,kBAAL,MAAAA,EAAA,WACE,KAAK,gBAAkB,MAAMtB,GAC3B,KACA,KAAK,QACL,KAAK,iBACL,KAAK,QAAQ,QAAA,CAEnB,CAOQ,wBAA+C,CAC9C,OAAA,QAAQ,IAAI,KAAK,uBAAuB,IAAI0B,GAAaA,EAAU,QAAQ,CAAC,CACrF,CAaQ,gBAAgBH,EAAmB,OACzC,MAAMI,EAAcJ,EAAM,OAEpBK,GAAmBN,EAAA,KAAK,iBAAL,YAAAA,EAAqB,SAASK,GAEnD,KAAK,QAAU,CAAC,KAAK,OAAO,cAAcJ,CAAK,GAAK,CAACK,GACvD,KAAK,MAAM,CAEf,CAEQ,aAAaC,EAAoB,CAChC,OAAAC,EAAA,QACL,KAAK,QACL,CACE,QAAS,CAAC,EAAG,CAAC,EACd,UAAW,CAAC,aAAc,UAAU,CACtC,EACA,CACE,SAAU,IACV,GAAID,EAAY,cAAgB,cAChC,OAAQ,cACR,UAAWA,EAAY,SAAW,UAClC,KAAM,MACR,EACA,KAAK,OAAA,CAET,CAEQ,mBAAmBA,EAAoB,CAC7C,GAAI,KAAK,YACA,OAAAC,EAAA,QAAQ,KAAK,YAAa,CAC/B,QAAS,CAAC,EAAG,CAAC,CAChB,EACA,CACE,SAAU,GACV,GAAID,EAAY,aAAe,aAC/B,OAAQ,cACR,UAAWA,EAAY,SAAW,UAClC,KAAM,MACR,EACA,KAAK,OAAA,CAET,CAUA,MAAc,wBAAwBA,EAAoB,CACxD,KAAK,OAASA,EACd,MAAM,KAAK,wBACb,CACF;EC5SME,GAAcC,EAAoB,oBAAA,EAExB,SAAAC,GAAYlB,EAAuCC,EAAqC,CACtG,OAAAe,GAAY7H,EAAG,EAED,IAAI4G,GAAsB,CACtC,UAAW,OACX,GAAGC,GACFC,CAAY,CAEjB"}